# 关键代码描述

#### 1. 并行构建叶子结点

- 由于是并发构建叶子结点，因此`fisrt_node`的位置是位于block块号1的位置，即：

```c++
int start_block = 1;     // position of first node, always be 1
int end_block = 0;       // position of last node
```



- 首先，创建并发线程，创建的线程数目通过函数`std::thread::hardware_concurrency()	`产生，而这个函数会返回能并发在一个程序中的线程数量。断言认为线程数量大于等于1，并且新开一个线程池`workerThreads`。

```c++
 const auto workerThreadsCount = std::thread::hardware_concurrency() - 1;
 assert(workerThreadsCount >= 1);
 std::vector<std::thread> workerThreads;
```



- 定义块头部的大小，key值空间的大小，entry的大小，树节点的容量，叶子结点的数量。并计算叶子结点数量与线程数量的比值。

```c++
const auto headerSize = SIZECHAR + SIZEINT * 3;
const auto keySize =
      ((int)ceil((float)file_->get_blocklength() / LEAF_NODE_SIZE) * SIZEFLOAT + SIZEINT);
const auto entrySize = SIZEINT;
const auto treeNodesCapacity =
      (file_->get_blocklength() - headerSize - keySize) / entrySize;
const auto leafNodesCount = (int)ceil((double)n / treeNodesCapacity);
const auto bound = leafNodesCount / workerThreadsCount;
```



- 创建一个用于并发控制的锁`lock`，便于互斥操作或访问互斥区。同时，让tree指针指向this指针。

```c++
auto lock = std::make_unique<SpinLock>();
auto tree = this;
```



- 创建了一个元组，其内有两种数据类型，分别为`int`和`BLeafNode*`。定义了比较函数`compare`：通过比较元组的第一个值判断。同时，创建了一个元组的优先队列，排序方式为自定义的`compare`类型，同时采用了小顶堆的排序方式。

```c++
using Tuple = std::tuple<int, BLeafNode *>;
const auto compare = [](const Tuple &a, const Tuple &b) {
    return std::get<0>(a) > std::get<0>(b);
  };
std::priority_queue<Tuple, std::vector<Tuple>, decltype(compare)> heap(
      compare);
```



- 消费者线程的工作：
  - `consumerThread`是用于接收 `workerThread` 输出的叶子节点 $N_i$，将它们按顺序连接（即设置左右指针），缓存一定数量的节点之后一次性地写入磁盘
  - 初始化：`processedNodes`是已经完成的节点，并把最后一个叶子结点`lastLeafIndex`的索引号设为-1，最后一个块`lastLeafIndex`的索引号设置为0。
  - 进入while循环，while循环的退出条件是所有叶子节点构建完成。即当前完成的节点数量大于等于叶子结点数量`processedNodes >= leafNodesCount`.
    - 首先让线程进入休眠，休眠10毫秒，然后进行上锁，并获取堆heap的大小，定义data的大小，并把`isFirst`设置为真，entryIndex的值设置为0.。
    - 当小顶堆不为空时，则`consumerThread`把小顶堆里面的叶子结点提取出来，并把叶子结点连接成双向链表，同时写入缓存区。
  - while循环的过程中，通过自旋锁来防止竞态条件。while循环结束后，就释放自旋锁。
  - 设置最后一个叶子结点的区块号，连接进双向链表，并写入缓存区。
  - 最后将若干个数量的节点一次性写入磁盘，即`lastBlockIndex = tree->file_->write_blocks(data, entryIndex, lastBlockIndex);`。
  - 释放内存空间。

```c++
  auto consumerThread =
      std::thread([&lock, &heap, tree, &end_block, &leafNodesCount, n] {
        int processedNodes = 0;
        int lastLeafIndex = -1;
        int lastBlockIndex = 0;  
        // 这里的情况和 start_block = 1 的原因一样，
        // file_ 里第一个 block 一定是树根节点

        while (processedNodes < leafNodesCount) {
          std::this_thread::sleep_for(std::chrono::milliseconds(10));

          lock->lock();
          const auto heapSize = heap.size();
          char *data = new char[heapSize * tree->file_->get_blocklength()];
          bool isFirst = true;
          int entryIndex = 0;
          BLeafNode *prev;
          while (!heap.empty()) {
            auto [leafIndex, leafNode] = heap.top();
            if (leafIndex != lastLeafIndex + 1) {
              break;
            }
            lastLeafIndex = leafIndex;
            processedNodes++;

            if (isFirst) {
              isFirst = false;
              if (lastBlockIndex > 0) {
                leafNode->set_left_sibling(lastBlockIndex);
              }
              leafNode->set_block(lastBlockIndex + entryIndex + 1);
              prev = leafNode;
            } else {
              leafNode->set_block(lastBlockIndex + entryIndex + 1);
              leafNode->set_left_sibling(prev->get_block());
              prev->set_right_sibling(leafNode->get_block());
              prev->write_to_buffer(data + (entryIndex - 1) *
                                               tree->file_->get_blocklength());
              delete prev;
              prev = leafNode;
            }

            entryIndex++;
            heap.pop();
          }
          lock->unlock();

          if (!entryIndex) {
            continue;
          }

          prev->set_block(lastBlockIndex + entryIndex);
          end_block = prev->get_block();
          if (end_block > n) {
            throw;
          }
          if (processedNodes < leafNodesCount) {
            prev->set_right_sibling(lastBlockIndex + entryIndex + 1);
          }
          prev->write_to_buffer(data + (entryIndex - 1) *
                                           tree->file_->get_blocklength());
          delete prev;
          prev = nullptr;

          // 这里写入的大小不是 heapSize 而是 entryIndex
          lastBlockIndex =
              tree->file_->write_blocks(data, entryIndex, lastBlockIndex);
          delete[] data;
          data = nullptr;
        }
      });
```



Worker线程的工作：

- 每个`workerThread`按照其下标顺序构建叶子节点。其中`emplace_back`的构造方式是就地构造，不用构造后再次复制到容器中。
- 进入外层for循环
  - 首先计算出`workerThread`自身对应的叶子结点的索引号。
  - 新构建一个叶子结点` leafNode = new BLeafNode()`，完成初始化后，忘叶子结点中添加`data.csv`中的数据（存于table中），即当该叶子结点未满（没超过叶子结点的容量时），往其中加入键值对（key和id）。叶子结点容量满时即退出内层for循环。
  - 由于所有叶子结点都要通过小顶堆传送给`consumerThread`，`consumerThread`中需要取出小顶堆中的叶子结点，因此对小顶堆的操作是互斥操作。因此给其上锁。
- 退出for循环时，所有叶子结点构建完成。

```c++
	for (int i = 0; i < workerThreadsCount; i++) {
    workerThreads.emplace_back(std::thread(
        [=, &lock, &heap](int id) {
          for (int h = 0; h <= bound; h++) {
            auto leafIndex = id + h * workerThreadsCount;
            if (leafIndex >= leafNodesCount) {
              continue;
            }
            auto leafNode = new BLeafNode();
            leafNode->init(0, tree);
            for (int k = 0; k < treeNodesCapacity; k++) {
              auto index = leafIndex * treeNodesCapacity + k;
              if (index >= n) {
                break;
              }
              auto id = table[index].id_;
              auto key = table[index].key_;
              leafNode->add_new_child(id, key);
              if (k < treeNodesCapacity - 1) {
                assert(!leafNode->isFull());
              }
            }
            lock->lock();
            heap.emplace(std::make_tuple(leafIndex, leafNode));
            lock->unlock();
          }
        },
        i));
  }
```



- 等待所有的线程运行完成，释放内存空间，进入索引节点的构建流程。

```c++
consumerThread.join();
for (auto &thread : workerThreads) {
	thread.join();
}
workerThreads.clear();
load_index_layers(start_block, end_block);
```



#### 2. 并行构建索引结点

- 初始化，因为是索引节点，因此此时的层数是从1开始，即令`current_level`为1。

```c++
int current_level = 1;               // current level (leaf level is 0)
int last_start_block = start_block;  // build b-tree level by level
int last_end_block = end_block;      // build b-tree level by level
```



- 同叶子结点。

```c++
const auto workerThreadsCount = std::thread::hardware_concurrency() - 1;
// const auto workerThreadsCount = 1;
assert(workerThreadsCount >= 1);
const auto headerSize = SIZECHAR + SIZEINT * 3;
const auto entrySize = SIZEFLOAT + SIZEINT;
// 一个 index node 的容量
const auto nodeCapacity = (file_->get_blocklength() - headerSize) / entrySize;
```



- 进入while循环，while循环内进行索引节点的分层构建，其中while循环的结束条件为：最后一个结束的块与最后一个开始块的块号相同。

  - 在while循环内，首先计算出需要扫描的 block 总数和需要构建的 index node 总数。

    ```c++
    // 这一层需要扫描的 block 总数
    const auto totalBlocksCount = last_end_block - last_start_block + 1;
    // 这一层要构建的 index node 总数
    const auto todoNodesCount =
            (int)ceil((double)totalBlocksCount / nodeCapacity)
    ```

  - 创建锁、元组tuple、线程等，同叶子结点。

    ```c++
    auto lock = std::make_unique<SpinLock>();
        auto tree = this;
        auto currentData = std::make_tuple<int, char *>(-1, nullptr);
    
        using Tuple = std::tuple<int, BIndexNode *>;
        const auto compare = [](const Tuple &a, const Tuple &b) {
          return std::get<0>(a) > std::get<0>(b);
        };
        std::priority_queue<Tuple, std::vector<Tuple>, decltype(compare)> heap(
            compare);
    
        std::vector<std::thread> workerThreads;
    ```

  - `composerThread`线程进行工作（详细见下）。

  - `workerThread`线程进行工作（详细见下）。

  - 等待所有的线程运行完成，释放内存空间，更新信息，更新当前层数。

    ```c++
        composerThread.join();
        for (auto &thread : workerThreads) {
          thread.join();
        }
    
        workerThreads.clear();
    
        last_start_block = start_block;  // update info
        last_end_block = end_block;      // build b-tree of higher level
        ++current_level;
    ```

- 更新根节点。

```c++
  root_ = last_start_block;  // update the <root>
```



消费者线程`composerThread`

- `composerThread`是用于接收 `workerThread` 输出的索引节点 $N_i$，将它们按顺序连接（即设置左右指针），缓存一定数量的节点之后一次性地写入磁盘。

- 初始化：已加载的block的数量设为0，以构建好的节点数量设为0，最后一个索引号为-1，令最后一个block的块号为end_block的块号（从并行构建叶子结点的函数传入并行构建索引节点函数）。

- 进入while循环，while循环的退出条件是索引节点构建完成。即当前完成的节点数量大于等于需要完成的索引结点数量`processedNodes >= todoNodesCount`.

  - 首先让线程进入休眠，休眠50毫秒，然后进行上锁，并获取堆heap的大小，定义data的大小，并把`isFirst`设置为真，entryIndex的值设置为0。
  - 当小顶堆不为空时，则`consumerThread`把小顶堆里面的索引结点提取出来，并把索引结点连接成双向链表，同时写入缓存区。

  - while循环的过程中，通过自旋锁来防止竞态条件。while循环结束后，就释放自旋锁。
  - 设置最后一个叶子结点的区块号，连接进双向链表，并写入缓存区。
  - 最后将若干个数量的节点一次性写入磁盘，即`lastBlockIndex = tree->file_->write_blocks(data, entryIndex, lastBlockIndex);`。
  - 释放内存空间，重新计算已完成的索引节点数目。

- 在这个工程中，对小顶堆的操作需上锁，使用完需释放锁。

```c++
    auto composerThread = std::thread([=, &lock, &heap, &todoNodesCount,
                                       &start_block, &end_block, &currentData] {
      int loadedBlocksCount = 0;
      int processedNodesCount = 0;
      int lastIndex = -1;
      int lastBlockIndex = last_end_block;

      while (processedNodesCount < todoNodesCount) {
        const auto loadedCount =
            std::min(nodeCapacity * 10000, totalBlocksCount - loadedBlocksCount);
        loadedBlocksCount += loadedCount;
        char *data = new char[tree->file_->get_blocklength() * loadedCount];
        assert(tree->file_->read_blocks(data,
                                        last_start_block + processedNodesCount,
                                        loadedCount) == true);
        lock->lock();
        currentData = {loadedCount, data};
        lock->unlock();

        auto processedCountOfCurrentRun = 0;
        const auto indexNodesCountOfCurrentRun =
            (int)ceil((double)loadedCount / nodeCapacity);
        while (processedCountOfCurrentRun < indexNodesCountOfCurrentRun) {
          std::this_thread::sleep_for(std::chrono::milliseconds(50));

          lock->lock();
          const auto heapSize = heap.size();
          char *data = new char[heapSize * tree->file_->get_blocklength()];
          bool isFirst = true;
          int entryIndex = 0;
          BIndexNode *prev;
          while (!heap.empty()) {
            auto [indexNodeIndex, indexNode] = heap.top();
            if (indexNodeIndex != lastIndex + 1) {
              break;
            }
            lastIndex = indexNodeIndex;
            processedCountOfCurrentRun++;

            if (isFirst) {
              isFirst = false;
              indexNode->set_block(lastBlockIndex + entryIndex + 1);
              if (lastBlockIndex > last_end_block) {
                indexNode->set_left_sibling(
                    lastBlockIndex);  // 不是第一个 block，直接和上一个
                                      // block 相连
              } else {
                start_block =
                    indexNode->get_block();  // 这是这个索引层的第一个 block
              }
              prev = indexNode;
            } else {
              indexNode->set_block(lastBlockIndex + entryIndex + 1);
              indexNode->set_left_sibling(prev->get_block());
              prev->set_right_sibling(indexNode->get_block());
              prev->write_to_buffer(data + (entryIndex - 1) *
                                               tree->file_->get_blocklength());
              delete prev;
              prev = indexNode;
            }

            entryIndex++;
            heap.pop();
          }
          lock->unlock();

          if (!entryIndex) {
            continue;
          }

          prev->set_block(lastBlockIndex + entryIndex);
          end_block = prev->get_block();  // 更新 end_block 指针
          if (processedNodesCount + processedCountOfCurrentRun <
              todoNodesCount) {
            prev->set_right_sibling(lastBlockIndex + entryIndex + 1);
          }
          prev->write_to_buffer(data + (entryIndex - 1) *
                                           tree->file_->get_blocklength());
          delete prev;
          prev = nullptr;

          // 这里写入的大小不是 heapSize 而是 entryIndex
          lastBlockIndex =
              tree->file_->write_blocks(data, entryIndex, lastBlockIndex);
          delete[] data;
          data = nullptr;
        }

        // 这一轮读取结束
        processedNodesCount += processedCountOfCurrentRun;
      }

      lock->lock();
      currentData = std::make_tuple<int, char *>(-1, nullptr);
      lock->unlock();
    });
```





Worker线程的工作：

- 每个`workerThread`按照其下标顺序构建索引节点。其中`emplace_back`的构造方式是就地构造，不用构造后再次复制到容器中。

- 初始化，对`blocksCountOfCurrentRun`和`data`进行初始化。

- 进入while外层循环。只能通过break退出循环

  - 进入while内层循环
    - 首先让workerThread休眠5毫秒。
    - 上锁，因为要对堆`currentData`进行操作，读出堆中的内容。
    - 释放锁。

  - 计算当前轮次的索引节点的数量，以及当前轮次索引节点的数量与`workThreads`的数量，存于`bound`中。

  - 进入for循环。

    - for循环内，首先计算出`workerThread`自身需要处理的`block`的部分，并据此构建出索引结点。
    - 新构建一个索引结点` indexNode = new BIndexNode()`，初始化，但是先不写入磁盘中。原因：索引节点在构建时需要获得儿子节点的 key，这就需要从磁盘读取信息。从整体来看，构建索引节点的过程会是多次的读—写—读循环，对硬盘的利用并不高效，因此我们修改了`b_node.h `和 `b_node.c`文件（对`BIndexNode`的类进行了修改）。如下所示，新增了函数。

    ```c++
    	virtual void init_no_write(
    		int   level,
    		BTree *btree);
    
    	virtual void init_restore_in_place(
    		BTree *btree,
    		int block,
    		Block data);
    
    	void add_new_child_no_dirty(
    		float key,
    		int son);
    ```

    ```c++
    void BIndexNode::init_no_write(int level, BTree *btree) {
      btree_ = btree;
      level_ = (char)level;
      num_entries_ = 0;
      left_sibling_ = -1;
      right_sibling_ = -1;
      dirty_ = false;
    
      // page size B
      int b_length = btree_->file_->get_blocklength();
      capacity_ = (b_length - get_header_size()) / get_entry_size();
      if (capacity_ < 50) {  // ensure at least 50 entries
        printf("capacity = %d, which is too small.\n", capacity_);
        exit(1);
      }
    
      key_ = new float[capacity_];
      son_ = new int[capacity_];
      //分配内存
      memset(key_, MINREAL, capacity_ * SIZEFLOAT);
      memset(son_, -1, capacity_ * SIZEINT);
    }
    ```

    - 计算block号，其中block号为`start_block`的值与`index`的值的和。
    - 根据当前层数不同（因为如果层数为1，需要连接叶子结点；其余层数不需要），调用自己编写的`init_restore_in_place`函数，一次性顺序读取大量的儿子节点到内存中。

    ```c++
    void BIndexNode::init_restore_in_place(BTree *btree, int block, Block data) {
      btree_ = btree;
      block_ = block;
      dirty_ = false;
    
      int b_len = btree_->file_->get_blocklength();
      capacity_ = (b_len - get_header_size()) / get_entry_size();
      if (capacity_ < 50) {
        printf("capacity = %d, which is too small.\n", capacity_);
        exit(1);
      }
    
      key_ = new float[capacity_];
      son_ = new int[capacity_];
      memset(key_, MINREAL, capacity_ * SIZEFLOAT);
      memset(son_, -1, capacity_ * SIZEINT);
    
      read_from_buffer(data);
    }
    ```

    - 往当前索引节点增加儿子节点，使用自己编写的函数`add_new_child_no_dirty`。

  ```c++
  void BIndexNode::add_new_child_no_dirty(
  	float key,
  	int   son)
  {
  	key_[num_entries_] = key;
  	son_[num_entries_] = son;
  	++num_entries_;
  }
  ```

  - 退出内层for循环。由于所有素音结点都要通过小顶堆传送给`composerThread`，`composerThread`中需要取出小顶堆中的索引结点，因此对小顶堆的操作是互斥操作。因此给其上锁。

- 退出for循环时，所有索引结点构建完成。

```c++
    for (int i = 0; i < workerThreadsCount; i++) {
      workerThreads.emplace_back(std::thread(
          [=, &currentData, &lock, &heap, &current_level, &end_block](int id) {
            int blocksCountOfCurrentRun = -1;
            char *data = nullptr;
            while (true) {
              while (true) {
                std::this_thread::sleep_for(std::chrono::milliseconds(5));
                lock->lock();
                if (std::get<1>(currentData) != data) {
                  if (data != nullptr && std::get<1>(currentData) == nullptr) {
                    lock->unlock();
                    return;
                  }
                  blocksCountOfCurrentRun = std::get<0>(currentData);
                  data = std::get<1>(currentData);
                  lock->unlock();
                  break;
                }
                lock->unlock();
              }

              const auto indexNodesCountOfCurrentRun =
                  (int)ceil((double)blocksCountOfCurrentRun / nodeCapacity);
              const auto bound =
                  indexNodesCountOfCurrentRun / workerThreadsCount;
              for (int h = 0; h <= bound; h++) {
                // 这个 index 是 composerThread 给的这一波 totalCount 个 block
                // 数据里的相对顺序 接下来这个 workerThread
                // 会算出自己应该处理哪一部分的block，构建出对应的 index node
                auto indexNodeIndex = id + h * workerThreadsCount;
                if (indexNodeIndex >= indexNodesCountOfCurrentRun) {
                  continue;
                }
                auto indexNode = new BIndexNode();
                indexNode->init_no_write(current_level, tree);
                for (int k = 0; k < nodeCapacity; k++) {
                  auto index = indexNodeIndex * nodeCapacity + k;
                  if (index >= blocksCountOfCurrentRun) {
                    break;
                  }
                  float key;
                  auto block =
                      start_block + index;  // 此时就已经可以知道 block 号了
                  if (current_level == 1) {
                    BLeafNode node;
                    node.init_restore_in_place(
                        tree, block,
                        data + tree->file_->get_blocklength() * index);
                    key = node.get_key_of_node();
                  } else {
                    BIndexNode node;
                    node.init_restore_in_place(
                        tree, block,
                        data + tree->file_->get_blocklength() * index);
                    key = node.get_key_of_node();
                  }
                  indexNode->add_new_child_no_dirty(key, block);
                  if (k < nodeCapacity - 1) {
                    assert(!indexNode->isFull());
                  }
                }
                lock->lock();
                heap.emplace(std::make_tuple(indexNodeIndex, indexNode));
                lock->unlock();
              }
            }
          },
          i));
    }
```

