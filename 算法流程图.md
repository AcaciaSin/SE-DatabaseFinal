# 算法流程图

注：需要初始化和赋值的内容太多，流程图里省略，具体见代码。

### 总算法流程图

```mermaid
graph TD
Begin(开始) -->Init[初始化]
    Init --> consumerThread[consumerThread]
    consumerThread --> op1[i =0]
    op1 --> for1{i< workerThread的数目}
    for1 --> |YES| workerThread[workerThread]
    workerThread --> op2[i++]
    op2 --> for1
    for1 --> |NO| wait[等待所有线程运行结束]
    wait --> free[释放空间]
    free --> load[调用构建索引节点函数load_index_layers]
    load --> End[结束]
```



#### 一、构建叶子结点

##### 1. consumerThread线程运行

```mermaid
graph TD
Begin(consumer线程开始运行) -->Init[初始化变量]
    Init --> con1{已完成构建的叶子结点数目 < 所有叶子结点的数目}
    con1 --> |YES| sleep[线程休眠10ms]
    con1 --> |NO| End[consumer线程结束运行]
    sleep --> lock[上锁]
    lock --> init[变量赋值]
    init --> con2{小顶堆heap不为空}
    con2 --> |YES| sleep[线程休眠10ms]
    sleep --> op1[取出小顶堆的堆顶]
    op1 --> if1{当前叶子索引号 != 上一个叶子索引号的值+1}
    if1 --> |YES| op2[上一个叶子索引号的值 = 当前叶子索引号,已完成构建的叶子结点数目+1]
    op2 --> if2{isFirst = True}
    if2 --> |YES| op3[1]
    if2 --> |NO| op4[2]
    op3 --> op5[entryIndex++]
    op4 --> op5
    op5 --> op6[弹出堆顶的元素]
    op6 --> con2
    if1 --> |NO| End[consumer线程结束运行]
    con2 --> |NO| unlock[解锁]
    unlock --> buildLastLeaf[构建最后一个叶子结点]
    buildLastLeaf --> free[释放内存]
    free[释放内存] -->Init
```



##### 2. workerThread线程运行 (for循环内的算法流程图)

```mermaid
graph TD
Begin(worker线程开始运行) -->Init[h = 0]
    Init --> con1{h < 叶子结点数量与线程数量的比值}
    con1 --> |YES| op1[叶子结点索引号leafIndex = id + h * workerThreadsCount]
    con1 --> |NO| End[worker线程结束运行]
    op1 --> if1{当前叶子索引号 >= 叶子结点总数}
    if1 --> |YES| op2[上一个叶子索引号的值 = 当前叶子索引号,已完成构建的叶子结点数目+1]
    if1 --> |No| op3
    op2 --> op3[新建叶子结点leafNode]
    op3 --> op4[初始化叶子结点]
    op4 --> op5[k=0]
    op5 --> con2{k < treeNodesCapacity}
    con2 --> |YES| op6[1]
    op6 --> op7[index = leafIndex * treeNodesCapacity + k]
    op7 --> if2{index >= entry的数目}
    if2 --> |YES| lock
    if2 --> |No| op8[id = table内第index项的id_]
    op8 --> op9[key = table内第index项的key_]
    op9 --> addChild[为叶子结点新增孩子]
    op7 --> if3{k < treeNodesCapacity - 1}
    if3 --> |YES| op10[断言叶子结点已满]
    op10 --> k[k++]
    k --> con2
    if3 --> k
    con2 --> |NO| lock[上锁]
    lock --> heapOp[对堆操作]
    heapOp --> unlock[解锁]
    unlock --> i[h++]
    i -->con1
```

#### 二、构建索引结点

##### 1. load_index_layers函数算法总流程

```mermaid
graph TD
Begin(开始) -->Init[初始化]
    Init --> con1{last_end_block > last_start_block}
    con1 --> |YES| init[初始化,创建线程]
    con1 --> |No| root[更新根节点 root_ = last_start_block]
    root --> End[结束]
    init --> composerThread[composerThread]
    composerThread --> op1[i =0]
    op1 --> for1{i< workerThread的数目}
    for1 --> |YES| workerThread[workerThread]
    workerThread --> op2[i++]
    op2 --> for1
    for1 --> |NO| wait[等待所有线程运行结束]
    wait --> update[更新变量]
    update --> con1
```

##### 2. composerThread线程运行

```mermaid
graph TD
Begin(consumer线程开始运行) -->Init[初始化变量]
    Init --> con1{已完成构建的索引结点数目 < 需要构建的索引结点的数目}
    con1 --> |YES| init[初始化变量]
    init --> lock2[上锁]
    lock2 --> heap2[对堆操作]
    heap2 --> unlock2[解锁]
    unlock2 --> init2[初始化变量]
    init2 --> con2{processedCountOfCurrentRun < indexNodesCountOfCurrentRun}
    con2 --> |YES| sleep[线程休眠50ms]
    sleep --> lock3[上锁]
    lock3 --> init3[赋值和初始化]
    init3 --> con3{堆不为空}
    con3 --> |YES| op3[取堆顶]
    op3 --> if2[indexNodeIndex != lastIndex + 1]
    if2 --> |YES| unlock3
    if2 --> |NO| op4[赋值]
    op4 --> if3{isFirst == True}
    if3 --> |YES| set[设置block号]
    if3 --> |NO| set2[设置block号,写入缓存区]
    set --> op5[entryIndex++]
    set2 --> op5
    op5 --> op6[pop堆顶的元素]
    op6 --> con3
    con3 --> |NO| unlock3[解锁]
    unlock3 --> if{entryIndex不为0}
    if --> |YES| goon[continue]
    if --> |NO| op1[设置最后一个索引节点]
    goon --> op1
    op1 --> free[释放空间]
    free --> con2
    con2 --> |NO| change[processedNodesCount += processedCountOfCurrentRun]
    change --> con1
    con1 --> |NO| lock[上锁]
    lock --> heap[对堆操作]
    heap --> unlock[解锁]
    unlock --> END[consumer线程结束运行]
    
```



##### 3. workerThread线程运行 (for循环内的算法流程图)

```mermaid
graph TD
Begin(worker线程开始运行) -->Init[初始化]
    Init --> con1{外层while循环永远为true}
    con1 --> |YES| con2{内层while循环永远为true}
    con2 --> |YES| sleep[线程休眠5ms]
    sleep --> lock[上锁]
    lock --> if1{std::get<1>currentData != data}
    if1 --> |YES| if2{data != nullptr && std::get<1>currentData == nullptr}
    if2 --> |Yes| unlock1[解锁]
    unlock1 --> End(退出load_index_layers函数)
    if2 --> |No| init[初始化]
    init --> unlock2[解锁]
    unlock2 --> init2[变量赋值,h=0,bound = indexNodesCountOfCurrentRun / workerThreadsCount]
    if1 --> |No| unlock[解锁]
    unlock--> con2
    
    init2 --> for{h <= bound,}
    for --> |YES| op1[计算需要处理的block]
    op1 --> op2[构建indexNode,并初始化]
    op2 --> for2{k < nodeCapacity}
    for2 --> |YES| op3[计算需要处理的block,indexNodeIndex = id + h * workerThreadsCount]
    op3 --> if3{index >= blocksCountOfCurrentRun}
    if3 --> |YES| lock3
    if3 --> |No| fuzhi[赋值]
    fuzhi --> if4{当前层数是否为1}
    if4 --> |YES| set[构建第一层的索引节点]
    if4 --> |No| set2[构建层数大于1的索引节点]
    set --> add[给索引节点增加儿子]
    set2 --> add
    add --> if5{k < nodeCapacity - 1}
    if5--> |YES| assert[断言索引节点未满]
    if5 --> |No| k[k++]
    assert --> k
    k --> for2
    for2 --> |No| lock3[上锁]
    lock3 --> heap[对堆操作]
    heap3 --> unlock3[解锁]
    unlock3 --> h[h++]
    h --> for
    for --> |No| con1
    
 
```

