## 数据库课程设计

### Bulkloading 过程

Bulkloading 的目标是对有序的数据批量构建 B+ 树。对于本次课程设计，它分为以下两个步骤：

* 构建叶子节点。本质是一层双向链表，链表的每个节点含有两个数组，一个存储键 `key`，另一个存储值 `id`，后者实质上是磁盘块的索引。一个 `key` 对应 16 个 `id`，这里主要是在节省磁盘空间和访问速度之间的权衡。
* 构建索引节点。本质是若干层的双向链表，每一层的一个节点会指向下一层的多个节点，以此达到 B+ 树的搜索功能。每个节点也有两个数组，一个存储 `key`，另一个存储指向叶子节点的磁盘块的指针，它们在数量上则是一比一的关系。

助教提供的源码采用串行化的加载算法，先构造叶子节点，后构造索引节点。

* 对于叶子节点，按顺序遍历输入的数据，逐个地构建出链表的节点。遍历结束之后构建完成。
* 对于索引节点，首先按顺序遍历叶子节点层里的所有节点，拿到它们的 `key` 和磁盘块指针，以此构建一层链表。之后，又以前面构建的一层链表构建新的一层链表，重复过程直到得到单个节点（也就是根节点）。

### 算法并行的设计思路

#### 构建叶子节点

经过分析发现，串行构建代码中存在以下可进行并行优化的点：

1. 可以将待构建的链表节点分为 N 份，由多线程并发地构建每一份，最后连接起来。
2. 对 `block_file.cc` 中 `BlockFile::append_block()` 函数的调用产生了大量的随机 IO，对于机械硬盘而言是非常严重的性能问题。因此，可以先缓存 `b_node.cc` 的 `BLeafNode::init()` 中对前者函数的调用，将多次随机 IO 转换为单次顺序 IO。

结合上述两点，得到这一步的并行设计思路：

设有 $N$ 个待构建的叶子节点，且待构建的叶子节点为 $N_i,i\in[0, 1, ..., N]$。设当前有 $M$ 个 CPU 逻辑核心。我们先不考虑 IO，则节点的构建是 CPU 密集型任务，因此可以使用 $M-1$ 个线程来高效地运行接下来的任务。令 $M_j$ 为第 $j$ 个线程，其中 $j\in [0, 1, ..., M-1]$。

对 $k=j+h(M-1),h\in[0,1,...,\lfloor \frac{N}{M-1} \rfloor-1]$，将 $N_k$ 分配给 $M_j$，这样每个线程都得到了 $\{N_i\}$ 的一部分。让它们各自按下标顺序开始构建叶子节点。我们这时使用另一个线程 $T_r$ 来接收 $M_j$ 输出的叶子节点 $N_i$，将它们按顺序连接（即设置左右指针）。

我们再引入另一个线程 $T_s$ 来接收从 $T_r$ 输出的完成连接的叶子节点，缓存到内存中，缓存的数量达到给定阈值之后一次性地写入磁盘。这里由于我们将原本的多次小规模的随机 IO 转换成了一次大规模的顺序 IO，效率会大大提升。

当所有节点都被线程 $T_s$ 落盘之后，它可以得到这一层节点的起始节点的指针以及末尾节点的指针，作为下一层的输入。

#### 构建索引节点



### 算法流程图

### 关键代码

### 实验结果

### 实验分析

### 性能调优

### 创新优化
